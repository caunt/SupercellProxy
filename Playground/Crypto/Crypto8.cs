using Playground.Crypto.NaCl;
using Playground.Crypto.NaCl.Internal.Blake2;

namespace Playground.Crypto;

/// <summary>
/// Implements method to encrypt or decrypt network traffic of the Clash of Clan protocol
/// version 8.x.x. This was based of clugh's work(https://github.com/clugh/cocdp/wiki/Protocol and
/// (https://github.com/clugh/coc-proxy-csharp). :]
/// </summary>
public class Crypto8 : Encryptor
{
    #region Constants
    private static readonly byte[] _standardPrivateKey = new byte[]
    {
            0x18, 0x91, 0xD4, 0x01, 0xFA, 0xDB, 0x51, 0xD2, 0x5D, 0x3A, 0x91, 0x74,
            0xD4, 0x72, 0xA9, 0xF6, 0x91, 0xA4, 0x5B, 0x97, 0x42, 0x85, 0xD4, 0x77,
            0x29, 0xC4, 0x5C, 0x65, 0x38, 0x07, 0x0D, 0x85
    };

    private static readonly byte[] _standardPublicKey = new byte[] // == PublicKeyBox.GenerateKeyPair(_standardPrivateKey);
    {
            0x72, 0xF1, 0xA4, 0xA4, 0xC4, 0x8E, 0x44, 0xDA, 0x0C, 0x42, 0x31, 0x0F,
            0x80, 0x0E, 0x96, 0x62, 0x4E, 0x6D, 0xC6, 0xA6, 0x41, 0xA9, 0xD4, 0x1C,
            0x3B, 0x50, 0x39, 0xD8, 0xDF, 0xAD, 0xC2, 0x7E
    };

    public static KeyPair StandardKeyPair
    {
        // Cloning just not to mess up with refs
        get { return new KeyPair((byte[])_standardPublicKey.Clone(), (byte[])_standardPrivateKey.Clone()); }
    }

    #region Constructors
    /// <summary>
    /// Initializes a new instance of the <see cref="Crypto8"/> class with the
    /// specified <see cref="Direction"/> and a generated <see cref="NaCl.KeyPair"/> using <see cref="GenerateKeyPair()"/>.
    /// </summary>
    /// <param name="direction">Direction of the data.</param>
    /// <exception cref="ArgumentException">Incorrect direction.</exception>
    public Crypto8(Direction direction) : this(direction, GenerateKeyPair())
    {
        // Space
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="Crypto8"/> class with the
    /// specified <see cref="Direction"/> and <see cref="NaCl.KeyPair"/>.
    /// </summary>
    /// <param name="direction">Direction of the data.</param>
    /// <param name="keyPair">Public and private key pair to use for encryption.</param>
    /// <exception cref="ArgumentException"><paramref name="direction"/> is incorrect.</exception>
    /// <exception cref="ArgumentNullException"><paramref name="keyPair"/> is null.</exception>"
    public Crypto8(Direction direction, KeyPair keyPair)
    {
        if (direction != Direction.Clientbound && direction != Direction.Serverbound)
            throw new ArgumentException("Cannot initialize Crypto8 with direction '" + direction + "'.", nameof(direction));
        if (keyPair == null)
            throw new ArgumentNullException(nameof(KeyPair));

        _direction = direction;
        _keyPair = keyPair;
    }
    #endregion

    #region Fields & Properties
    /// <summary>
    /// Gets the version of the <see cref="CoCCrypto"/>.
    /// </summary>
    public override int Version => 8;

    /// <summary>
    /// Gets the current <see cref="NaCl.KeyPair"/> used by the <see cref="Crypto8"/> to encrypt or decrypt data.
    /// </summary>
    public KeyPair KeyPair => _keyPair;

    /// <summary>
    /// Gets the shared public key.
    /// </summary>
    /// <remarks>
    /// It can either be 'k', 'pk' or 'serverkey' depending on the state.
    /// </remarks>
    public byte[] SharedKey => _sharedKey;

    /// <summary>
    /// Gets the direction of the data.
    /// </summary>
    public Direction Direction => _direction;

    // Precomputered shared key.
    private KeyPair _precompKey;

    private readonly KeyPair _keyPair;
    private readonly Direction _direction;

    // Other end's public key can either be clientkey(pk), serverkey and k.
    private byte[] _sharedKey;
    // Generated by hashing (clientKey, serverKey) or (snonce, clientKey, serverKey).
    private byte[] _blake2bNonce;
    // Can either be snonce or rnonce according to _direction.
    private byte[] _encryptNonce;
    // Can either be snonce or rnonce according to _direction.
    private byte[] _decryptNonce;
    // Crypto state. To have an idea where we are in the authentication.
    internal CryptoState _cryptoState;
    #endregion

    internal enum CryptoState
    {
        None = 0,
        // First key.
        InitialKey = 1,
        // snonce given.
        BlakeNonce = 2,
        // k given by the server, after 20104.
        SecoundKey = 3
    }

    /// <summary>
    /// Encrypts the provided bytes(plain-text).
    /// </summary>
    /// <param name="data">Bytes to encrypt.</param>
    public override void Encrypt(ref byte[] data)
    {
        if (data == null)
            return;

        switch (_cryptoState)
        {
            case CryptoState.InitialKey:
            case CryptoState.BlakeNonce:
                data = PublicKeyBox.Box(data, _sharedKey, _keyPair.PrivateKey, _blake2bNonce);
                break;

            case CryptoState.SecoundKey:
                IncrementNonce(_encryptNonce);

                data = SecretBox.Box(data, _sharedKey, _encryptNonce);
                break;

            default:
                throw new InvalidOperationException("Cannot encrypt in current state.");
        }
    }

    /// <summary>
    /// Decrypts the provided bytes(cipher-text).
    /// </summary>
    /// <param name="data">Bytes to decrypt.</param>
    public override void Decrypt(ref byte[] data)
    {
        if (data == null)
            return;

        switch (_cryptoState)
        {
            case CryptoState.InitialKey:
            case CryptoState.BlakeNonce:
                data = PublicKeyBox.Open(data, _sharedKey, _keyPair.PrivateKey, _blake2bNonce);
                break;

            case CryptoState.SecoundKey:
                IncrementNonce(_decryptNonce);

                data = SecretBox.Open(data, _sharedKey, _decryptNonce);
                break;

            default:
                throw new InvalidOperationException("Cannot decrypt in current state.");
        }
    }

    /// <summary>
    /// Updates the <see cref="Crypto8"/> with the other end's public key according to the <see cref="Direction"/>
    /// the <see cref="Crypto8"/> was initialized with.
    /// </summary>
    /// <remarks>
    /// The Blake2B nonce will be generated depending on the state of the <see cref="Crypto8"/>.
    /// </remarks>
    /// <param name="publicKey">Other end's public key.</param>
    /// <exception cref="ArgumentNullException"><paramref name="publicKey"/> is null.</exception>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="publicKey"/> length is not 32.</exception>
    public void UpdateSharedKey(byte[] publicKey)
    {
        if (publicKey == null)
            throw new ArgumentNullException(nameof(publicKey));
        if (publicKey.Length != PublicKeyBox.PublicKeyLength)
            throw new ArgumentOutOfRangeException(nameof(publicKey), "Key must be 32 bytes in length.");

        if (_cryptoState == CryptoState.SecoundKey)
            throw new InvalidOperationException("Cannot update 'k' because it has already been set.");
        else if (_cryptoState == CryptoState.None)
        {
            // Order of keys is important. 
            // We're the server.
            if (Direction == Direction.Clientbound)
                _blake2bNonce = GenerateBlake2BNonce(publicKey, _keyPair.PublicKey);
            // We're the client.
            else
                _blake2bNonce = GenerateBlake2BNonce(_keyPair.PublicKey, publicKey);

            // We got initial key and Blake nonce.
            _cryptoState = CryptoState.InitialKey;
        }
        else
        {
            // Make sure we have a decrypt nonce before decrypting with k.
            if (_decryptNonce == null)
                throw new InvalidOperationException("Cannot update shared key 'k' because did not provide a decrypt nonce.");

            // Make sure we have an encrypt nonce before encrypting with k
            if (_encryptNonce == null)
                throw new InvalidOperationException("Cannot update shared key 'k' because did not provide an encrypt nonce.");

            _cryptoState = CryptoState.SecoundKey;
        }

        _sharedKey = publicKey;
    }

    /// <summary>
    /// Updates the specified <see cref="UpdateNonceType"/> with the specified nonce.
    /// </summary>
    /// <param name="nonce">Nonce to use for the update.</param>
    /// <param name="nonceType">Nonce type to update.</param>
    /// <exception cref="ArgumentNullException"><paramref name="nonce"/> is null.</exception>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="nonce"/> length is not 24.</exception>
    public void UpdateNonce(byte[] nonce, UpdateNonceType nonceType)
    {
        if (_cryptoState == CryptoState.SecoundKey)
            throw new InvalidOperationException("Cannot update nonce after updated with shared key 'k'.");
        if (nonce == null)
            throw new ArgumentNullException(nameof(nonce));
        if (nonce.Length != 24)
            throw new ArgumentOutOfRangeException(nameof(nonce), "nonce must be 24 bytes in length.");

        switch (nonceType)
        {
            case UpdateNonceType.Blake:
                if (_cryptoState == CryptoState.InitialKey)
                {
                    if (Direction == Direction.Clientbound) // order of keys is important. we're the server
                        _blake2bNonce = GenerateBlake2BNonce(nonce, _sharedKey, _keyPair.PublicKey);
                    else // we're the client
                        _blake2bNonce = GenerateBlake2BNonce(nonce, _keyPair.PublicKey, _sharedKey);

                    _cryptoState = CryptoState.BlakeNonce; // use blake nonce
                }
                break;

            case UpdateNonceType.Decrypt:
                _decryptNonce = nonce;
                break;

            case UpdateNonceType.Encrypt:
                _encryptNonce = nonce;
                break;

            default:
                throw new ArgumentException("Unexpected NonceType: " + nonceType, "nonceType");
        }
    }

    /// <summary>
    /// Generates a <see cref="NaCl.KeyPair"/>.
    /// </summary>
    /// <returns>Generated <see cref="NaCl.KeyPair"/>.</returns>
    public static KeyPair GenerateKeyPair()
    {
        var keyPair = PublicKeyBox.GenerateKeyPair();
        return new KeyPair(keyPair.PublicKey, keyPair.PrivateKey);
    }

    /// <summary>
    /// Generates a <see cref="NaCl.KeyPair"/> from the specified private key.
    /// </summary>
    /// <param name="privateKey">Private key from which to generate the <see cref="NaCl.KeyPair"/>.</param>
    /// <returns>Generated <see cref="NaCl.KeyPair"/>.</returns>
    public static KeyPair GenerateKeyPair(byte[] privateKey)
    {
        var keyPair = PublicKeyBox.GenerateKeyPair(privateKey);
        return new KeyPair(keyPair.PublicKey, keyPair.PrivateKey);
    }

    /// <summary>
    /// Generates a 24 bytes long nonce.
    /// </summary>
    /// <remarks>
    /// This is a wrapper around <see cref="PublicKeyBox.GenerateNonce()"/>.
    /// </remarks>
    /// <returns>Generated 24 bytes long nonce.</returns>
    public static byte[] GenerateNonce()
    {
        return PublicKeyBox.GenerateNonce();
    }

    // Generate blake2b nonce with clientkey(pk) and serverkey.
    private static byte[] GenerateBlake2BNonce(byte[] clientKey, byte[] serverKey)
    {
        var hashBuffer = new byte[clientKey.Length + serverKey.Length];

        Buffer.BlockCopy(clientKey, 0, hashBuffer, 0, clientKey.Length);
        Buffer.BlockCopy(serverKey, 0, hashBuffer, PublicKeyBox.PublicKeyLength, serverKey.Length);

        using (var blake = new Blake2B(24))
            return blake.ComputeHash(hashBuffer);
    }

    // Generate blake2b nonce with snonce, clientkey and serverkey.
    private static byte[] GenerateBlake2BNonce(byte[] snonce, byte[] clientKey, byte[] serverKey)
    {
        var hashBuffer = new byte[clientKey.Length + serverKey.Length + snonce.Length];

        Buffer.BlockCopy(snonce, 0, hashBuffer, 0, PublicKeyBox.NonceLength);
        Buffer.BlockCopy(clientKey, 0, hashBuffer, PublicKeyBox.NonceLength, clientKey.Length);
        Buffer.BlockCopy(serverKey, 0, hashBuffer, PublicKeyBox.NonceLength + PublicKeyBox.PublicKeyLength, serverKey.Length);

        using (var blake = new Blake2B(PublicKeyBox.NonceLength))
            return blake.ComputeHash(hashBuffer);
    }

    // Increment nonce by 2.
    private static void IncrementNonce(byte[] nonce)
    {
        ushort c = 2;
        for (int i = 0; i < nonce.Length; i++)
        {
            c += nonce[i];
            nonce[i] = (byte)c;

            // 8 bits right shift to get the carry.
            c >>= 8;
        }
    }
}
#endregion
